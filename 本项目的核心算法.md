

[TOC]

# 操作数运算算法

(将在下个版本中补充介绍)

# 表达式检查的算法

1. 对表达式进行【静态检查】和【动态检查】。如果检查不通过，向提示框发送异常信息，本算法结束。如果通过，进行下一步。
2. 判断输入的表达式是否`不以等号结尾但以数字或结尾`。如果是尝试补齐等号，然后进行下一步。如果不是，进行 5。
3. 对补充等号的表达式进行【静态检查】和【动态检查】。如果通过，进行下一步。如果检查不通过，说明表达式不完整但没有语法错误，且自行添加等号是不合理的，那么就向提示框发送默认信息，本算法结束。
4. 对补充等号的表达式进行实时计算，并向提示框发送计算结果。
5. （进行到此处说明 1、2 均为通过，3 不通过。）判断输入的表达式是否完整，如果是，向结果框发送计算过程，本算法结束。如果不是，进行下一步。
6. 如果用户输入的只是等号，本算法直接结束。如果是其它情况，向提示框发送默认信息，本算法结束。

# 单个字符语法检查的算法

(将在下个版本中补充介绍)



# 表达式计算的算法

(将在下个版本中补充介绍)



# 显示计算过程的算法

6. (将在下个版本中补充介绍)



# 通信算法

1. 如何低耦合地获取接收者的句柄？

   原待改进设计：一个控件拥有可以直接访问任何其它控件对象的权限。

   答：改为获取控制器的句柄。

2. 如何来使控制器拥有不同的行为来真正取代目标控件。

   原问题：控制器一定是没有目标控件的方法的，那么信息发送者如何把控制器当成目标控件呢？

   答：使用 URL。在 URL 中给出具体的目标控件信息与方法名、参数等。

3. 如何优化控制器的设计，避免一个控制器的算法过于复杂。

   原问题：

   1. 如果只使用一个控制器，则该控制器将直接与所有的控件进行通信，职责过重。如果使用多个控制器，如何决定哪个控件与哪个控制器进行通信。
   2. 如果使用多级控制器，每一个控制器如何判断发送给它的信息来自上级还是下级？

   答：将通信行为划分成 4 个方法，2 个接口，使用多级控制器与具体控件进行通信。

   具体来说，将控制器分为 2 种（分别实现上述的 2 个接口），每种控制器有 2 个不同的方法。

   * 一种控制器是中间控制器。它分为两种：

     + 非中央控制器。它只做 2 件事情：
       * 将下级控制器向上传递的信息直接原封不动地向上传递。【方法 sendUp】
       * 将上级控制器向下传递的信息继续向下传递。它需要决定将信息向下发送给哪个下级控制器。【方法 sendDown】

     - 中央控制器。它只做 2 件事情：
       * 将下级控制器向上传递的信息准备向下传递。【方法 sendUp】
       * 决定将向下传递的信息传递给哪个下级控制器。【方法 sendDown】

   * 另一种是终端控制器。它要做 4 件事情：

     - 将来自具体控件的信息交给【方法 sendUp】来处理。【方法 send】
     - 将来自【方法 send】的信息向上传递。【方法 sendUp】
     - 将上级控制器向下传递的信息交给【方法 receive】来处理。【方法 sendDown】
     - 将来自【方法 sendDown】的信息发送给具体控件。【方法 receive】

   这样划分的理由：

   1. 当控制器接收到下层控制器发送的信息时，它并不知道应该如何找到接收方，所以它只能将信息发送给中央控制器，让中央控制器来判断。而找到中央控制器的办法就是，将信息发送给上级控制器。
   2. 当控制器接收到上层控制器发送的信息时，它清楚的知道这个消息只能向下传递。不过，它还需要判断发送给哪个下级控制器。
   3. 虽然这种设计使得每条信息都要经过中央控制器，好像没有减轻中央控制器的负担。但实际上，中央控制器只需要决定将消息传给哪个二级控制器，而不需要定位到具体的控件。因为二级控制器的数量一定小于具体控件的数量，所以这确实减轻了中央控制器的负担，而将原来的负担分散给了各级控制器。
   4. 可以实现前端界面与后端服务之间的解耦。
   5. 每个控制器都是无状态的。



# 旧算法

## 操作数运算算法（旧版本 M.1.1）

1. 将操作数与操作数之间的运算分离。

2. 对所有的操作数定义一个抽象超类，并将在数学上范围大的数定义为范围小的数的子类。

3. 对所有的运算定义一个抽象超类，但具体的运算符之间不设计为继承关系。

4. 将运算分为协变运算与稳定运算。对于稳定运算，其形参的类型的稳定的。对于协变运算，其形参的类型将由操作数类型的扩大而多变，因此会形成多个重载方法。

   为了减少重载方法的个数，将对二元及以上的运算的操作数进行排列，将它们中的子类排列在前，超类排列在后，然后再调用相应的运算方法。这样的好处是，可以不编写形参类型为超类在前、子类在后的运算方法，减少编写的运算方法个数。

   具体的步骤是，对某一个运算类的某一个名称的运算方法，先定义一个形参类型为操作数的抽象超类的导航方法。该使用反射检查形参的类型，并将它们按继承关系，将子类排列在前。然后按排列后的形参顺序调用相应的方法，同时追加相应的补充运算来抵消重排列操作数带来的副作用。

* 该算法解决的难点：

  - 继承一般情况下，应该是含义上更通用、抽象，范围上更大的概念作为超类，但本设计则相反。以整数、有理数为例。看起来整数应该是有理数的特例，但从设计上，有理数内部需要用整数来构造。如果将整数定义为有理数的子类，则在依赖上将形成循环：创建一个有理数时，需要先创建它的整数分子、分母，因此会调用整数的构造器。又因为有理数是整数的超类，所以在创建整数时，会调用有理数的构造器。这就形成了循环调用。
  
    由于协变运算的重载，为了减少重载方法的个数，这里也不适合使用组合来表示，下面将解释其中的缘由。
  
  - 形参的重排序。对于协变运算，由于操作数类型多样，需要编写的重载方法较多。考虑到不同数的范围有大小之分，可以将范围大的数放在前面，从而减少接近一半的重载方法的编写。
  
  - 操作数类型的协变。对于协变运算，由于操作数之间的继承关系，可能会导致超类的运算类去处理子类的操作数。然而由于上面的继承倒置，超类的运算类不支持去处理子类的操作数。
  
    一种解决办法是，让子类运算类全覆盖超类的协变运算方法，不过由于协变方法的重载众多，如果覆盖出现遗漏，这将导致风险。
  
    另一种解决办法是，解除具体运算类之间的继承关系，而保留操作数之间的继承关系。这在一定程度上可以降低调用不当重载方法的风险，不过不能从根本解决这个问题。

## 显示计算过程的算法（旧版本 M.1.2）

（假设输入的表达式已经通过了语法检查以及预计算。）

1. 如果表达式为空，什么也不干，本算法结束。否则，进行下一步。

2. 将等号前面的原表达式输出，然后进行下一步。

3. 将原表达式反转，以提供输入流供输入。

4. 进入循环。当循环结束时，进入 6。循环的持续执行条件是：（下面的条件满足一个即可）

   1. 输入流不为空
   2. 已读取表达式为空
   3. 最近一个已读取字符（不是当前正在读取的字符）为等号

5. 循环中某一次的内容为：

   1. 如果`当前正在读取的字符`为等号，且`运算符栈`为空，将`操作数缓存栈`的数转换成完整操作数后加入`操作数栈`并将`已读取表达式栈`插入一个转换符。然后将`正在读取的字符`加入`运算符栈`、`已读取表达式栈`中，最后进入下一次循环。

      如果不是，进行下一步。

   2. 如果`当前正在读取的字符`不为上面的条件，且为数字或小数点，将`正在读取的字符`加入`操作数缓存栈`，然后从输入流中读取一次输入，进入下一次循环。

      如果不是，进行下一步。

   3. 如果`当前正在读取的字符`不为上面的条件，说明本次的输入是一个运算符。于是将`操作数缓存栈`中的数转换成完整操作数后加入`操作数栈`并将`已读取表达式栈`插入一个转换符，然后进行下一步。

   4. 如果`运算符栈`为空，将运算符送入`运算符栈`、`已计算表达式栈`，然后从输入流中读取一次输入，进入下一次循环。如果不为空，进行下一步。

   5. 比较当前输入的运算符与已读取的最近一个运算符的优先级。如果结果为：

      * 小于：将运算符送入`运算符栈`、`已计算表达式栈`，然后从输入流中读取一次输入，进入下一次循环

      * 等于：说明比较的这两个运算符为成对的括号，这就是说，这对括号里面没有其它运算符，就只有一个操作数。那么就将左括号从`运算符栈`、`已计算表达式栈`中弹出。将左括号从`已计算表达式栈`中弹出的方法是，先将前面提到的操作数弹出，然后将左括号弹出，最后将前面被迫弹出的操作数送回栈中。

      * 大于：从`操作数栈`中弹出这二元运算符的两个操作数，从`运算符栈`中弹出这个二元运算符，从`已计算表达式栈`中弹出三个元素。然后使用这些弹出的操作数、运算符进行计算，并将计算结果送入`操作数栈`，将`已读取表达式栈`插入一个转换符。最后展示计算结果，将`至少进行了一次运算的标识`设为 true，进入下一次循环。

        展示计算结果的算法如下：

        1. 将`输入流栈`、`已读取表达式栈`备份。
        2. 将当前读取的运算符加入`备份的输入流栈`，然后将该栈反转。
        3. 将`备份的已读取表达式栈`与`备份的输入流栈`进行拼接。
        4. 输出`备份的已读取表达式栈`。

6. 如果在循环中，至少进行了一次运算，最后将结果转化为浮点数显示。如果没有， 说明表达式过于简单，就将原表达式输出。

